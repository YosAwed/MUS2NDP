#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import math
import os
import sys
import argparse
import traceback
from pathlib import Path

__all__ = ["convert_mml_file"]

# --- MUS to NDP Mappings ---
# オクターブのオフセット（必要に応じて調整）
MUS_TO_NDP_OCTAVE_OFFSET = 0  

# トラックIDのマッピング (MUSトラックID → NDPトラックID)
MUS_TO_NDP_TRACK_MAP = {
    'A': '1', 'B': '2', 'C': '3', 'D': '4', 
    'E': '5', 'F': '6', 'G': '7', 'H': '8'
}

# --- 定数定義 ---
MUS_TICKS_PER_BEAT = 48  # MUS形式の1拍あたりのティック数
NDP_PLAYER_FPS = 60  # NDPプレイヤーのFPS
ARPEGGIO_SLICE_MUS_TICKS = 24  # アルペジオスライスのティック数（未使用）
NDP_ARPEGGIO_NOTE_LENGTH_COMMAND = "LA32"  # アルペジオのノート長コマンド（未使用）
NDP_TIMEBASE = 48  # NDPのタイムベース

# ノート名から相対的なMIDIノート番号へのマッピング
MIDI_NOTE_VALUES_RELATIVE = {
    "C": 0, "C+": 1, "D-": 1, "D": 2, "D+": 3, "E-": 3, 
    "E": 4, "F": 5, "F+": 6, "G-": 6, "G": 7, "G+": 8, 
    "A-": 8, "A": 9, "A+": 10, "B-": 10, "B": 11
}

# ノート名の変換マップ (MUS形式からNDP形式へ)
MUS_TO_NDP_NOTE_MAP = {
    'c': 'c', 'c+': 'c+', 'd-': 'c+', 'd': 'd', 'd+': 'd+', 'e-': 'd+',
    'e': 'e', 'f': 'f', 'f+': 'f+', 'g-': 'f+', 'g': 'g', 'g+': 'g+',
    'a-': 'g+', 'a': 'a', 'a+': 'a+', 'b-': 'a+', 'b': 'b',
    'r': 'r'  # 休符
}

def parse_mus_file(content, verbose=False):
    """
    MUSファイルの内容をパースして、トラックデータとメタデータを抽出します。
    (Refactored to handle @t and @instrument on track lines)
    """
    print(f"DEBUG parse_mus_file START: verbose flag is {verbose}")
    result = {'title': '', 'composer': '', 'tracks': {}, 'track_instruments': {}, 'voice_definitions': {}, 'mus_tempo': None}
    current_track = None
    track_data_list_for_current_track = []
    VALID_MUS_TRACK_CHARS = "ABCDEFGH" # Ensure this is defined

    lines = content.splitlines()
    for i, line_raw in enumerate(lines):
        line_num_for_debug = i + 1
        line_stripped = line_raw.strip()

        if verbose:
            print(f"DEBUG parse_mus_file: LOOP TOP - Line {line_num_for_debug}: '{line_stripped[:100]}'")

        if not line_stripped or line_stripped.startswith(';') or line_stripped.startswith('*'):
            if verbose:
                print(f"DEBUG parse_mus_file: Skipping comment/empty line {line_num_for_debug}")
            continue

        if line_stripped.upper().startswith("#TITLE"):
            result['title'] = line_stripped[len("#TITLE"):].strip().replace('"', '')
            if verbose: print(f"DEBUG parse_mus_file: Found Title: {result['title']}")
            continue
        if line_stripped.upper().startswith("#COMPOSER"):
            result['composer'] = line_stripped[len("#COMPOSER"):].strip().replace('"', '')
            if verbose: print(f"DEBUG parse_mus_file: Found Composer: {result['composer']}")
            continue
        
        # Instrument voice definitions (e.g., "@ 69={ ... }")
        if line_stripped.startswith('@') and '=' in line_stripped and '{' in line_stripped and '}' in line_stripped:
            parts = line_stripped.split('=', 1)
            inst_id_key = parts[0].strip() # e.g. "@ 69"
            inst_data_str = parts[1].strip()
            if inst_data_str.startswith('{') and inst_data_str.endswith('}'):
                result['voice_definitions'][inst_id_key] = inst_data_str
                if verbose: print(f"DEBUG parse_mus_file: Found Voice Definition for {inst_id_key}")
            continue

        # Track data processing logic
        line_starts_with_track_char = False
        potential_track_id = ''
        if line_stripped and line_stripped[0].isalpha() and line_stripped[0].isupper() and line_stripped[0] in VALID_MUS_TRACK_CHARS:
            line_starts_with_track_char = True
            potential_track_id = line_stripped[0]

        if line_starts_with_track_char:
            data_after_potential_track_id = line_stripped[1:] # Includes leading space if present
            
            # Check for definition commands (@t, @NN) in the data part of the line
            # Ensure regex matches @NN (instrument) not @NN= (voice definition already handled)
            is_definition_command_present = '@t' in data_after_potential_track_id or \
                                           bool(re.search(r"@\s*\d+(?!\s*=)", data_after_potential_track_id.lstrip()))

            if current_track is None or potential_track_id != current_track or is_definition_command_present:
                # Case 1: Truly new track, different track, or re-definition of current track
                if verbose:
                    print(f"DEBUG parse_mus_file: Detected new/redefined track line: '{line_stripped[:70]}'")
                if current_track is not None and track_data_list_for_current_track:
                    data_to_save = ' '.join(track_data_list_for_current_track).strip()
                    if data_to_save:
                        if verbose:
                            print(f"DEBUG parse_mus_file: About to save to result['tracks']['{current_track}'] data starting with: '{data_to_save[:30]}'")
                        result['tracks'][current_track] = data_to_save
                        if verbose:
                            print(f"DEBUG parse_mus_file: Saved data for prev track '{current_track}'. Data(70): '{data_to_save[:70]}'")

                current_track = potential_track_id
                track_data_list_for_current_track = [] # Reset
                if verbose:
                    print(f"DEBUG parse_mus_file: Starting/redefined track '{current_track}'. List reset.")

                value_to_pass = data_after_potential_track_id.lstrip()
                print(f"FORCE DEBUG parse_mus_file: About to call preprocess_and_extract with: '{value_to_pass[:100]}'")

                processed_data_from_line, _, mus_tempo_from_line = preprocess_and_extract_data_from_track_line(
                    value_to_pass, 
                    current_track,
                    result['track_instruments'],
                    verbose=verbose
                )
                if mus_tempo_from_line is not None and result['mus_tempo'] is None:
                    result['mus_tempo'] = mus_tempo_from_line
                    # Always print this important information, regardless of verbose flag
                    print(f"DEBUG parse_mus_file: Stored initial MUS tempo: {result['mus_tempo']} (extracted from line)")

                if processed_data_from_line:
                    track_data_list_for_current_track.append(processed_data_from_line)
                    if verbose:
                        print(f"DEBUG parse_mus_file: Track '{current_track}' - appended processed data from its own definition line: '{processed_data_from_line[:70]}'")
            
            else:
                # Case 2: Line starts with the SAME track char as current_track, but not a re-definition.
                # This is a continuation line where the track letter is restated.
                value_to_pass_continued = data_after_potential_track_id.lstrip()
                print(f"FORCE DEBUG parse_mus_file: About to call preprocess_and_extract for continued line with: '{value_to_pass_continued[:100]}'")
                continuation_data, _, mus_tempo_from_continued_line = preprocess_and_extract_data_from_track_line(
                    value_to_pass_continued,
                    current_track,
                    result['track_instruments'],
                    verbose=verbose
                )
                if mus_tempo_from_continued_line is not None and result['mus_tempo'] is None:
                    result['mus_tempo'] = mus_tempo_from_continued_line
                    if verbose:
                        print(f"DEBUG parse_mus_file: Stored initial MUS tempo from continued line: {result['mus_tempo']}")

                if continuation_data:
                    track_data_list_for_current_track.append(continuation_data)
                    if verbose:
                        print(f"DEBUG parse_mus_file: Track '{current_track}' - appended continuation (same letter, no def): '{continuation_data[:70]}'")
        
        elif current_track and line_stripped:
            # Case 3: Normal continuation line (does not start with a track character)
            track_data_list_for_current_track.append(line_stripped)
            if verbose:
                print(f"DEBUG parse_mus_file: Track '{current_track}' - appended normal continuation line: '{line_stripped[:70]}'")
        
        elif verbose: # No current track and not a line that starts one (e.g. unexpected format)
            print(f"DEBUG parse_mus_file: Skipping unhandled line: '{line_stripped[:70]}'")

    # Save the last processed track's data
    if current_track is not None and track_data_list_for_current_track:
        data_to_save = ' '.join(track_data_list_for_current_track).strip()
        if data_to_save:
            if verbose:
                print(f"DEBUG parse_mus_file: About to save to result['tracks']['{current_track}'] (FINAL TRACK) data starting with: '{data_to_save[:30]}'")
            result['tracks'][current_track] = data_to_save
            if verbose:
                print(f"DEBUG parse_mus_file: Saved data for FINAL track '{current_track}'. Data(70): '{data_to_save[:70]}'")

    if verbose:
        print_final_tracks_for_debug(result['tracks'])

    return result

def print_final_tracks_for_debug(tracks_dict):
    print("DEBUG parse_mus_file: --- Final content of result['tracks'] ---")
    for track_key, data in sorted(tracks_dict.items()):
        print(f"DEBUG parse_mus_file: Final Track '{track_key}': '{data[:100]}...' (Total length: {len(data)})")
    print("DEBUG parse_mus_file: --- End of Final content of result['tracks'] ---")


def preprocess_and_extract_data_from_track_line(line_content, track_char, track_instruments_dict, verbose=False):
    # Print verbose flag status
    print(f"DEBUG preprocess_and_extract: Function called with verbose={verbose} for track '{track_char}'")
    # FORCE DEBUG PRINT
    print(f"FORCE DEBUG preprocess_and_extract: track='{track_char}', received line_content='{line_content[:100]}'")
    # 0. Strip leading whitespace from line_content first
    line_content_stripped = line_content.lstrip()
    print(f"FORCE DEBUG preprocess_and_extract: track='{track_char}', line_content_stripped='{line_content_stripped[:100]}'")

    # 1. Extract and remove track tempo like @tXXX from this line's data part
    extracted_tempo = None
    
    # トラック内に直接テンポ指定文字列が存在するかチェック
    if '@t' in line_content_stripped:
        print(f"DEBUG: '@t' exists in the line: {line_content_stripped[:50]}")
    
    # 複数のテンポパターンを試みる
    tempo_patterns = [
        r'@t(\d+)',           # 基本的なパターン: @t220
        r'@t\s+(\d+)',        # スペース入りパターン: @t 220
        r'@\s*t\s*(\d+)'      # 任意のスペース: @ t 220
    ]
    
    tempo_match = None
    for pattern in tempo_patterns:
        tempo_match = re.search(pattern, line_content_stripped)
        if tempo_match:
            extracted_tempo = int(tempo_match.group(1))
            print(f"TEMPO FOUND: Track '{track_char}' - Pattern '{pattern}' matched '@t{extracted_tempo}'")
            # マッチした部分を削除
            line_content_stripped = line_content_stripped[:tempo_match.start()] + line_content_stripped[tempo_match.end():]
            line_content_stripped = line_content_stripped.lstrip()
            print(f"TEMPO EXTRACTION: Track='{track_char}', ExtractedTempo='{extracted_tempo}', After={line_content_stripped[:30]}")
            break
    
    if extracted_tempo is not None:
        print(f"Final Tempo: Track '{track_char}' - extracted tempo = {extracted_tempo}")
    # Else, if no tempo match, line_content_stripped remains as is for the next step

    # 2. Extract and remove track-specific instrument like @NN from this line's data part
    instrument_match = re.match(r'@(\d+)', line_content_stripped)
    if instrument_match:
        instrument_id_val = instrument_match.group(1)
        track_instruments_dict[track_char] = f"@{instrument_id_val}"
        line_content_stripped = line_content_stripped[instrument_match.end():].lstrip() # Use lstrip() after slicing
        if verbose:
            print(f"DEBUG parse_mus_file: Track '{track_char}' - found instrument @{instrument_id_val}. Remaining: '{line_content_stripped[:70]}'")
    
    # Return the finally processed (stripped and definitions removed) line content
    return line_content_stripped, track_instruments_dict, extracted_tempo

def split_track_data(track_data_str, channel_prefix, max_length=70, verbose=False):
    """
    単一の長いMMLトラック文字列を、プレフィックス付きの複数行に分割します。
    Args:
        track_data_str: トラックのMMLデータ文字列（プレフィックスなし）。
        channel_prefix: チャンネルプレフィックス（例: "1", "A"）。
        max_length: 1行あたりのMMLデータ部分の最大長。
        verbose: 詳細ログ出力フラグ。
    Returns:
        list: プレフィックスが付与されたMML行文字列のリスト。
    """
    lines = []
    if not track_data_str.strip():
        lines.append(f"{channel_prefix}")
        if verbose: print(f"DEBUG split_track_data for prefix '{channel_prefix}': Input was empty/whitespace. Output: {lines}")
        return lines

    current_pos = 0
    track_len = len(track_data_str)
    # VALID_BREAK_CHARS: These characters can safely start a new line segment.
    # Based on user feedback:音名（a,b,c）か、不等号（<>) -> abcdefgr<>
    VALID_BREAK_CHARS = "abcdefgr<>" # Add other command chars like 'o','v','l','q','t','@','[' if needed

    while current_pos < track_len:
        intended_split_point = min(current_pos + max_length, track_len)
        actual_split_point = intended_split_point # Default if no better break is found

        if intended_split_point < track_len: # Only adjust if not the very last segment
            # Try to find a syntactically valid break by scanning backwards
            # k is the index in track_data_str where the new line would start
            found_syntax_break = False
            for k in range(intended_split_point - 1, current_pos, -1):
                if track_data_str[k].lower() in VALID_BREAK_CHARS:
                    actual_split_point = k
                    found_syntax_break = True
                    break
            
            # If no syntax break was found by scanning backwards (actual_split_point is still intended_split_point),
            # or if the found syntax break is too short, consider a space if it's better.
            # For now, prioritize the found syntax_break if any.
            # If syntax break makes the line very short, and a space further along is valid, that might be better.
            # Current simple logic: if found_syntax_break, use it. Otherwise, it's intended_split_point.

            # Fallback or refinement: check for a space if it leads to a valid start
            # This is a bit simplified; a more complex heuristic could choose between space and syntax break.
            if not found_syntax_break: # If syntax scan didn't improve from intended_split_point
                last_space_idx = track_data_str.rfind(' ', current_pos, intended_split_point)
                if last_space_idx > current_pos: # Found a space
                    potential_split_at_space = last_space_idx + 1
                    # Check if char after space is a valid MML start
                    if potential_split_at_space < track_len and \
                       track_data_str[potential_split_at_space].lower() in VALID_BREAK_CHARS:
                        actual_split_point = potential_split_at_space
                    # If space doesn't lead to a valid start, stick with intended_split_point (hard cut)
                    # (unless the syntax scan already found something better than intended_split_point)
                    # This 'if not found_syntax_break' block means we are currently at intended_split_point
                    # and trying if a space is better than a hard cut at intended_split_point.

        # Ensure progress is made, especially if max_length is small or no valid breaks are found.
        if actual_split_point <= current_pos and current_pos < track_len:
            # This might happen if loop for k finds nothing and actual_split_point remains current_pos+max_length
            # and that leads to no progress. Or if max_length=0 or 1.
            actual_split_point = min(current_pos + 1, track_len) # Force advance by at least one character
            if actual_split_point <= current_pos and current_pos < track_len: # Still stuck (e.g. track_len is 0, or pos is at end)
                 actual_split_point = track_len # Go to end to terminate loop

        line_content = track_data_str[current_pos:actual_split_point].strip()

        if line_content:
            lines.append(f"{channel_prefix} {line_content}")
        elif not lines and current_pos == 0 and track_data_str.strip():
            # First segment is empty but original had content, should not happen with current logic much
            pass 

        current_pos = actual_split_point
        # Skip leading spaces for the next segment (if any)
        while current_pos < track_len and track_data_str[current_pos] == ' ':
            current_pos += 1

    if not lines and track_data_str.strip():
        lines.append(f"{channel_prefix} {track_data_str.strip()}")

    if verbose: print(f"DEBUG split_track_data for prefix '{channel_prefix}': Input(len {track_len})='{track_data_str[:50]}...', Output lines ({len(lines)}): {lines[:3] if lines else []}")
    return lines

def process_mus_commands(track_data, track_key, verbose=False, is_pdx_mode=False, current_timebase=NDP_TIMEBASE):
    """
    MUSコマンドをMMLコマンドに変換します。(初期コマンド処理の再調整)
    
    Args:
        track_data: MUSトラックデータ (cleaned by parse_mus_file)
        track_key: トラック番号 (1-8) # This is MML channel prefix
    Returns:
        list: MML文字列のリスト（各行が要素）
    """

    # NDPプレイヤーのタイムベースに基づいてノート長を計算
    # NDP_TIMEBASE = 48 # MUS_TICKS_PER_BEAT と同じと仮定

    if verbose: print(f"\n--- process_mus_commands: Track {track_key} ---") 
    if verbose: print(f"Input track_data (first 100): '{track_data[:100]}'") 

    initial_mml_commands = []
    note_sequence_parts = []
    current_octave_mus = 4  # MUSのデフォルトオクターブはo4とされることが多い
    mus_volume = -1 # 未設定を示す
    mus_gate_rate = -1 # q (Gate Time Rate / Release Rate)
    mus_quantize_denom = 8 # p (Default Quantize, e.g., p1 means 1/8, p2 means 1/16)

    # --- L command handling --- 
    if verbose: print(f"DEBUG L-CMD: Track {track_key} - Before L replacement attempt, track_data (first 100): '{track_data[:100]}'")
    has_l_command = False
    # Search for 'L' followed by a space (to avoid matching 'LOAD' etc.)
    # More robustly, use a regex that matches 'L' as a whole word followed by space(s)
    if re.search(r"\bL\s+", track_data): 
        track_data_before_l = track_data
        track_data = re.sub(r"\bL\s+", "[ ", track_data, 1) # Replace first occurrence of 'L ' (or 'L  ') with '[ '
        if track_data != track_data_before_l:
            has_l_command = True
            if verbose: print(f"DEBUG L-CMD: Track {track_key} - 'L' command REPLACED. New track_data (first 100): '{track_data[:100]}'")
        else:
            if verbose: print(f"DEBUG L-CMD: Track {track_key} - 'L' command found by search but NOT replaced by sub. track_data (first 100): '{track_data[:100]}'")
    else:
        if verbose: print(f"DEBUG L-CMD: Track {track_key} - 'L ' (L followed by space) NOT found by re.search. track_data (first 100): '{track_data[:100]}'")
    if verbose: print(f"DEBUG L-CMD: Track {track_key} - After L replacement attempt, track_data (first 100): '{track_data[:100]}'")
    # --- End L command handling ---

    # 正規表現パターンのコンパイル（キャッシュ付き）
    cache_key = (is_pdx_mode)
    if cache_key not in MEMOIZED_NOTE_PATTERNS:
        # MUSのDコマンドは無視（MMLでは直接対応なし）
        # MUSのpコマンド（クオンタイズパラメータ）は無視
        # MUSのLコマンド（ループ）はMMLの[]に変換するが、ここではノート処理なので直接は扱わない
        # v, o, q はMMLに変換
        note_pattern_mus = r"([cdefgab])([+\-]?)(-?)(\d+|\^)?(\.)?"
        if is_pdx_mode: #PDX specific: @ (volume envelope), E (pitch envelope), P (pitch LFO)
            note_pattern_mus = r"([@EP])?([cdefgab])([+\-]?)(-?)(\d+|\^)?(\.)?|([r])(\d+|\^)?(\.)?|([tvqo])(-?\d+)"
        else: # Default (MUS/NDP)
            note_pattern_mus = r"([cdefgab])([+\-]?)(-?)(\d+|\^)?(\.)?|([r])(\d+|\^)?(\.)?|([tvqo])(-?\d+)"
        MEMOIZED_NOTE_PATTERNS[cache_key] = re.compile(note_pattern_mus, re.IGNORECASE)
    note_regex = MEMOIZED_NOTE_PATTERNS[cache_key]

    current_data = track_data.strip() # Process from a stripped copy for initial commands
    if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Starting initial command loop. current_data (first 50): '{current_data[:50]}'")

    # 最初のコマンド群を処理 (v, o, q, p, D など)
    # このループは、current_dataの先頭からコマンドを剥ぎ取っていく
    while True:
        original_len = len(current_data)

        # v (Volume) コマンド
        vol_match = re.match(r"[vV](-?\d+)\s*", current_data)
        if vol_match:
            mus_volume = int(vol_match.group(1))
            mml_volume = min(max(0, mus_volume + 1), 15) # MUS v0-14 to MML v1-15 (approx)
            initial_mml_commands.append(f"v{mml_volume}")
            current_data = current_data[vol_match.end():].lstrip()
            if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Parsed 'v{mus_volume}' -> mml_v{mml_volume}. Remaining: '{current_data[:30]}'")
            continue

        # o (Octave) コマンド
        oct_match = re.match(r"[oO](\d)\s*", current_data)
        if oct_match:
            current_octave_mus = int(oct_match.group(1))
            initial_mml_commands.append(f"o{current_octave_mus}")
            current_data = current_data[oct_match.end():].lstrip()
            if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Parsed 'o{current_octave_mus}'. Remaining: '{current_data[:30]}'")
            continue

        # q (Gate Time Rate / Release Rate) コマンド
        q_match = re.match(r"[qQ](-?\d+)\s*", current_data)
        if q_match:
            mus_gate_rate = int(q_match.group(1))
            # MMLのq (Gate Quantize) とは意味が異なる。NDPでは直接対応するqはない想定。値を保持しコメント等で利用可能性あり。
            # initial_mml_commands.append(f"q{mus_gate_rate}") # Example if we were to map it
            current_data = current_data[q_match.end():].lstrip()
            if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Parsed 'q{mus_gate_rate}' (MUS gate rate). Remaining: '{current_data[:30]}'")
            continue

        if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Before 'p' match attempt, current_data: '{current_data[:50]}'")
        # p (Quantize Parameter) コマンド - MUS独自なので除去 (MMLでは解釈されない)
        p_match = re.match(r"[pP]([1-8])\s*", current_data)
        if p_match:
            mus_quantize_denom = int(p_match.group(1))
            current_data = current_data[p_match.end():].lstrip()
            if verbose:
                print(f"DEBUG InitialCMD: Track {track_key} - Parsed and REMOVED 'p{mus_quantize_denom}'. Remaining: '{current_data[:30]}'")
            continue

        if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Before 'D' match attempt, current_data: '{current_data[:50]}'")
        # D (Default Note Length) コマンド - MUS独自なので除去 (MMLでは解釈されない)
        d_match = re.match(r"[dD](-?\d+)\s*", current_data) # D-4 なども考慮
        if d_match:
            # default_length_mus = d_match.group(1) # MMLでは使用しないので値は保持しない
            current_data = current_data[d_match.end():].lstrip()
            if verbose:
                print(f"DEBUG InitialCMD: Track {track_key} - Parsed and REMOVED 'D{d_match.group(1)}'. Remaining: '{current_data[:30]}'")
            continue
        
        # ループで何も処理されなかった (マッチするコマンドがなかった) ら抜ける
        if len(current_data) == original_len:
            if verbose: print(f"DEBUG InitialCMD: Track {track_key} - No more initial commands matched. Breaking loop. Remaining data: '{current_data[:50]}'")
            break
    
    if verbose: print(f"DEBUG InitialCMD: Track {track_key} - After initial command loop. Final initial_mml_commands: {initial_mml_commands}")
    if verbose: print(f"DEBUG InitialCMD: Track {track_key} - Data remaining for note processing: '{current_data[:100]}'")
    note_sequence_parts.append(current_data) # 残ったものがノートシーケンス

    # ノートシーケンスの解析と変換 (ここは元のロジックをベースに調整が必要な場合あり)
    # この段階では current_data にはノートと一部のMMLコマンド（r, t, >, < など）が残っている想定
    # ここでさらに詳細なノート変換処理を実装する
    # (現状は current_data をそのまま note_sequence_parts に追加しているが、将来的にはここで MUS ノート -> MML ノート変換)

    # MML文字列の組み立て
    output_mml = "".join(initial_mml_commands) + "".join(note_sequence_parts)

    if has_l_command:
        output_mml += "]"
        if verbose:
            print(f"DEBUG L-CMD: Track {track_key} - Appended ']' for L command. MML end hint: '...{output_mml[-50:]}'")

    return output_mml # ここでは単一のMML文字列を返す (分割は呼び出し元で行う)

MEMOIZED_NOTE_PATTERNS = {}

# グローバルキャッシュ用
NOTE_CONVERSION_CACHE = {}
MEMOIZED_NOTE_PATTERNS = {}

# MMLの1行あたりの最大文字数（MMLE/NDP準拠、トラックプレフィックス除く）
MAX_LINE_LENGTH_MMLE = 70

def convert_mml_file(mus_filepath, conversion_mode="default", note_length_mode="frames"):
    """
    MUSファイルをMML形式に変換します。
    (Refactored to use parse_mus_file for track extraction)
    
    Args:
        mus_filepath: 入力MUSファイルのパス
        conversion_mode: (現在は主にMML生成のため影響小)
        note_length_mode: (現在は主にMML生成のため影響小)
    Returns:
        str: 変換されたMML形式の文字列
    """
    # conversion_mode validation (kept for signature compatibility)
    if conversion_mode not in ["default", "direct_8track"]:
        # For MML conversion, this might not be strictly necessary, but keep for now
        print(f"Warning: conversion_mode '{conversion_mode}' might not be fully applicable for MML output.")
    
    try:
        with open(mus_filepath, 'r', encoding='utf-8', errors='replace') as f:
            mus_content = f.read()
    except Exception as e:
        return f"Error reading MUS file: {e}"

    # Parse the MUS file content using the dedicated parser
    if verbose:
        print("DEBUG: About to call parse_mus_file with verbose flag")
    parsed_data = parse_mus_file(mus_content, verbose=verbose) # Pass the verbose flag from parameter
    if verbose:
        print(f"DEBUG: After parse_mus_file, mus_tempo = {parsed_data.get('mus_tempo')}")

    title = parsed_data.get('title', "Untitled")
    composer = parsed_data.get('composer', "Unknown")
    mus_tempo = parsed_data.get('mus_tempo') # Get the extracted MUS tempo
    
    timebase = 48 # Default MML timebase
    if 'NDP_TIMEBASE' in globals(): # Check if global constant exists and prefer it
        timebase = NDP_TIMEBASE

    mml_output_parts = [
        f'#TITLE "{title}"',
        f'#COMPOSER "{composer}"',
        f'#TIMEBASE {timebase}',
    ]

    # Add tempo command if mus_tempo is available
    if mus_tempo is not None and 1 <= mus_tempo <= 255: # Ensure tempo is in a valid range
        try:
            bpm = round((60 * 4000000) / (40 * 1024 * (256 - mus_tempo)))
            
            # Determine active NDP tracks for the tempo command
            active_ndp_tracks_for_tempo = []
            # Ensure MUS_TO_NDP_TRACK_MAP is accessible here or define/pass it
            # Assuming MUS_TO_NDP_TRACK_MAP is globally defined as per previous context
            if parsed_data.get('tracks'):
                sorted_mus_keys_for_tempo = sorted(parsed_data['tracks'].keys())
                for mus_key in sorted_mus_keys_for_tempo:
                    ndp_track_num = MUS_TO_NDP_TRACK_MAP.get(mus_key.upper())
                    if ndp_track_num:
                        active_ndp_tracks_for_tempo.append(ndp_track_num)
                
                if active_ndp_tracks_for_tempo:
                    # Sort by numeric value of track number string
                    active_ndp_tracks_for_tempo.sort(key=int) 
                    tempo_track_prefix = "".join(active_ndp_tracks_for_tempo)
                    mml_output_parts.append(f'{tempo_track_prefix} T{bpm}')
        except ZeroDivisionError:
            print(f"Warning: MUS tempo {mus_tempo} resulted in division by zero. Tempo command skipped.")
        except Exception as e:
            print(f"Warning: Error calculating BPM from MUS tempo {mus_tempo}: {e}. Tempo command skipped.")

    mml_output_parts.append('') # Blank line after header (and potentially tempo)

    # Instrument definitions (add as comments)
    if parsed_data.get('voice_definitions'): 
        mml_output_parts.append("// Voice Definitions (from MUS @ NN={...})")
        for voice_id, voice_data_str in sorted(parsed_data['voice_definitions'].items()):
            # Clean up voice data string for comment display
            voice_comment = str(voice_data_str).replace('\n', ' ').replace('\r', ' ').replace('\t', ' ')
            voice_comment = re.sub(r'\s+', ' ', voice_comment).strip()
            mml_output_parts.append(f"// {voice_id} = {voice_comment}")
        mml_output_parts.append('') # Blank line after voice definitions
    
    # Also, consider if track_instruments should be listed if they are simple @NN
    if parsed_data.get('track_instruments'):
        has_simple_track_instruments = any(val for val in parsed_data['track_instruments'].values())
        if has_simple_track_instruments:
            mml_output_parts.append("// Track-specific Instrument Assignments (from MUS Track @NN)")
            for track_char, inst_id_str in sorted(parsed_data['track_instruments'].items()):
                if inst_id_str: # Ensure there's an instrument assigned
                     mml_output_parts.append(f"// Track {track_char}: {inst_id_str}")
            mml_output_parts.append('') # Blank line

    # --- DEBUG: Contents of parsed_data['tracks'] before loop ---
    print("\nDEBUG convert_mml_file: --- Contents of parsed_data['tracks'] before loop ---")
    if 'tracks' in parsed_data and isinstance(parsed_data['tracks'], dict):
        for key, value in parsed_data['tracks'].items():
            print(f"DEBUG convert_mml_file: Track '{key}': '{str(value)[:100]}'")
    else:
        print("DEBUG convert_mml_file: 'tracks' key not found or not a dict in parsed_data")
    print("DEBUG convert_mml_file: --- End Contents of parsed_data['tracks'] ---\n")
    # --- END DEBUG ---

    # Track data processing
    # Use MUS_TO_NDP_TRACK_MAP for mapping MUS track chars (A,B,C) to MML channel numbers (1,2,3)
    # This map is globally defined in the file.
    
    processed_tracks_output = []
    # Sort by MUS track character for consistent MML output order
    sorted_mus_track_keys = sorted(parsed_data.get('tracks', {}).keys())
    print(f"DEBUG convert_mml_file: Sorted MUS track keys for loop: {sorted_mus_track_keys}") # DEBUG

    for mus_track_key in sorted_mus_track_keys:
        print(f"DEBUG convert_mml_file: LOOP START: Current mus_track_key = '{mus_track_key}'") # DEBUG
        full_mus_track_data = parsed_data['tracks'][mus_track_key]
        mml_channel_id = MUS_TO_NDP_TRACK_MAP.get(mus_track_key.upper())
        verbose_flag = parsed_data.get('verbose', False) # parse_mus_fileからverboseフラグを取得

        if not mml_channel_id:
            # print(f"Warning: Skipping MUS track '{mus_track_key}' as it has no MML channel mapping.")
            continue

        processed_tracks_output.append(f"// トラック {mus_track_key.upper()} (チャンネル {mml_channel_id})")
        
        # Call process_mus_commands with the full track data and the MML channel ID
        # process_mus_commands は単一のMML文字列を返すように変更された
        single_mml_track_string = process_mus_commands(
            full_mus_track_data, 
            mml_channel_id, 
            verbose=verbose_flag, 
            is_pdx_mode=False, # is_pdx_mode は必要に応じて調整
            current_timebase=timebase
        )
        
        # --- DEBUG: Before splitting --- 
        if verbose_flag:
            print(f"\nDEBUG convert_mml_file: For MUS track '{mus_track_key}' (MML Channel '{mml_channel_id}')")
            print(f"DEBUG convert_mml_file: Data from process_mus_commands (first 100): '{str(single_mml_track_string)[:100]}'")
        # --- END DEBUG ---
        
        # 単一のMML文字列を、新しいsplit_track_dataを使って行に分割
        mml_track_lines_split = split_track_data(
            single_mml_track_string, 
            mml_channel_id, 
            max_length=MAX_LINE_LENGTH_MMLE, 
            verbose=verbose_flag
        )
        
        processed_tracks_output.extend(mml_track_lines_split)
        processed_tracks_output.append('') # Add a blank line after each track's MML content

    mml_output_parts.extend(processed_tracks_output)
    
    final_mml_content = "\n".join(mml_output_parts).strip()
    # Ensure the file ends with a newline, even if it's empty
    return final_mml_content + "\n" if final_mml_content else "\n"

def convert_mml_file(mus_filepath, conversion_mode="default", note_length_mode="frames"):
    """
    MUSファイルをNDP形式に変換します。
    
    Args:
        mus_filepath: 入力MUSファイルのパス
        conversion_mode: 変換モード ('default' または 'direct_8track')
        note_length_mode: ノート長の変換モード ('frames' または 'ticks')
    Returns:
        str: 変換されたNDP形式の文字列
    """
    # 変換モードの検証
    if conversion_mode not in ["default", "direct_8track"]:
        return f"エラー: 無効な変換モード: {conversion_mode}"
    
    # ノート長モードの検証
    if note_length_mode not in ["frames", "ticks"]:
        return f"エラー: 無効なノート長モード: {note_length_mode}"
    try:
        with open(mus_filepath, 'r', encoding='utf-8', errors='replace') as f:
            mus_content = f.read()
    except Exception as e:
        return f"Error reading MUS file: {e}"

    # MUSファイルからタイトルと作曲者を抽出
    mus_title = re.search(r"#TITLE\s*(.*)", mus_content, re.IGNORECASE)
    mus_composer = re.search(r"#COMPOSER\s*(.*)", mus_content, re.IGNORECASE)
    mus_title_str = mus_title.group(1).strip() if mus_title else "Untitled"
    mus_composer_str = mus_composer.group(1).strip() if mus_composer else "Unknown Composer"

    # NDPフォーマットのヘッダーを設定
    converted_mml_content = f'#TITLE "{mus_title_str}"\n#COMPOSER "{mus_composer_str}"\n#TIMEBASE {NDP_TIMEBASE}\n\n'

    # MUSファイルの前処理（コメントや不要な定義を削除）
    mus_content_no_meta = preprocess_mus_remove_definitions_and_comments(mus_content)
    
    tracks_data_mus = {}
    current_track_id_mus = None
    for line in mus_content_no_meta.splitlines():
        line_stripped = line.strip()
        if not line_stripped:
            continue

        # トラックIDのパターン (#A-Hで始まり、その後ろにMMLデータが続く形式)
        # グループ1: トラックID (例: "A", "B")
        # グループ2: トラックIDの後のMMLデータ
        track_match = re.match(r'^#([A-H])\s*(.*)', line_stripped, re.IGNORECASE)

        if track_match:
            # MUS形式では #A, #B のような形式なので、グループ1がトラックID
            current_track_id_mus = track_match.group(1).upper()
            
            if current_track_id_mus not in tracks_data_mus:
                tracks_data_mus[current_track_id_mus] = []
            
            # トラックID行自体に含まれるMMLデータを取得
            mml_data_on_track_line = track_match.group(2).strip()
            if mml_data_on_track_line:
                tracks_data_mus[current_track_id_mus].append(mml_data_on_track_line)
        elif current_track_id_mus is not None:
            # 前の行がトラックID行で、現在の行がその続きのMMLデータの場合
            tracks_data_mus[current_track_id_mus].append(line_stripped)
    
    # MUSトラックIDからNDPトラックIDへのマッピング
    mus_to_ndp_track_map = {
        'A': '1', 'B': '2', 'C': '3', 'D': '4', 'E': '5', 'F': '6', 'G': '7', 'H': '8'
    }
    
    # トラックデータの処理と変換
    processed_tracks = []
    for mus_track_id, mus_track_lines in tracks_data_mus.items():
        # MUSトラックをトークン化
        mus_track_tokens = tokenize_mus_track_data(mus_track_lines)
        
        # トラックIDのマッピング（MUSトラックID → NDPトラックID）
        target_ndp_track_id = mus_to_ndp_track_map.get(mus_track_id, mus_track_id)
        
        # 変換モードに応じたトラックIDの処理
        if conversion_mode == "direct_8track" and mus_track_id in mus_to_ndp_track_map:
            # 8トラック直接マッピングモード
            target_ndp_track_id = mus_to_ndp_track_map[mus_track_id]
        elif mus_track_id not in mus_to_ndp_track_map:
            # 定義されていないトラックIDはスキップ
            continue

        # トラックデータをNDP形式に変換
        track_data_converted = convert_track_data(
            mus_track_tokens, 
            initial_octave=4, 
            initial_default_len=8, 
            initial_bpm=120,
            mus_channel_id=mus_track_id, 
            target_ndp_track_id=target_ndp_track_id,
            conversion_mode=conversion_mode, 
            note_length_conversion_mode=note_length_mode
        )
        
        if track_data_converted.strip():  # 空のトラックは追加しない
            processed_tracks.append((target_ndp_track_id, track_data_converted))
    
    # NDPトラックIDでソートしてから結合 (辞書順ではなく数値順ソートを意識)
    processed_tracks.sort(key=lambda x: int(x[0]) if x[0].isdigit() else float("inf")) 
    for ndp_id, track_content_raw in processed_tracks:
        if track_content_raw.strip(): # 空のトラックは追加しない
            # 各行の先頭にトラックIDを付与する
            track_lines_with_id = []
            for line in track_content_raw.splitlines():
                if line.strip(): # 空行は無視
                    track_lines_with_id.append(f"{ndp_id} {line.strip()}")
            if track_lines_with_id: # トラックに内容がある場合のみ追加
                converted_mml_content += "\n" + "\n".join(track_lines_with_id) + "\n"
    
    # 変換結果を返す
    return converted_mml_content.strip() # 末尾の余分な改行を削除

def convert_mml_file(mus_filepath, conversion_mode="default", note_length_mode="frames"):
    """
    MUSファイルをMML形式に変換します。
    (Refactored to use parse_mus_file for track extraction)
    
    Args:
        mus_filepath: 入力MUSファイルのパス
        conversion_mode: (現在は主にMML生成のため影響小)
        note_length_mode: (現在は主にMML生成のため影響小)
    Returns:
        str: 変換されたMML形式の文字列
    """
    # conversion_mode validation (kept for signature compatibility)
    if conversion_mode not in ["default", "direct_8track"]:
        # For MML conversion, this might not be strictly necessary, but keep for now
        print(f"Warning: conversion_mode '{conversion_mode}' might not be fully applicable for MML output.")
    
    try:
        with open(mus_filepath, 'r', encoding='utf-8', errors='replace') as f:
            mus_content = f.read()
    except Exception as e:
        return f"Error reading MUS file: {e}"

    # Parse the MUS file content using the dedicated parser
    parsed_data = parse_mus_file(mus_content) # parse_mus_file should be defined before this

    title = parsed_data.get('title', "Untitled")
    composer = parsed_data.get('composer', "Unknown")
    
    timebase = 48 # Default MML timebase
    if 'NDP_TIMEBASE' in globals(): # Check if global constant exists and prefer it
        timebase = NDP_TIMEBASE

    mml_output_parts = [
        f'#TITLE "{title}"',
        f'#COMPOSER "{composer}"',
        f'#TIMEBASE {timebase}',
        '' # Blank line after header
    ]

    # Instrument definitions (add as comments)
    if parsed_data.get('instruments'):
        mml_output_parts.append("// インストゥルメント定義")
        for inst_id, inst_data_str in sorted(parsed_data['instruments'].items()):
            # Clean up instrument data string for comment display
            inst_comment = str(inst_data_str).replace('\n', ' ').replace('\r', ' ').replace('\t', ' ')
            inst_comment = re.sub(r'\s+', ' ', inst_comment).strip() # Replace multiple spaces
            mml_output_parts.append(f"// {inst_id} = {inst_comment}")
        mml_output_parts.append('') # Blank line

    # --- DEBUG: Contents of parsed_data['tracks'] before loop ---
    print("\nDEBUG convert_mml_file: --- Contents of parsed_data['tracks'] before loop ---")
    if 'tracks' in parsed_data and isinstance(parsed_data['tracks'], dict):
        for key, value in parsed_data['tracks'].items():
            print(f"DEBUG convert_mml_file: Track '{key}': '{str(value)[:100]}'")
    else:
        print("DEBUG convert_mml_file: 'tracks' key not found or not a dict in parsed_data")
    print("DEBUG convert_mml_file: --- End Contents of parsed_data['tracks'] ---\n")
    # --- END DEBUG ---

    # Track data processing
    # Use MUS_TO_NDP_TRACK_MAP for mapping MUS track chars (A,B,C) to MML channel numbers (1,2,3)
    # This map is globally defined in the file.
    
    processed_tracks_output = []
    # Sort by MUS track character for consistent MML output order
    sorted_mus_track_keys = sorted(parsed_data.get('tracks', {}).keys())
    print(f"DEBUG convert_mml_file: Sorted MUS track keys for loop: {sorted_mus_track_keys}") # DEBUG

    for mus_track_key in sorted_mus_track_keys:
        print(f"DEBUG convert_mml_file: LOOP START: Current mus_track_key = '{mus_track_key}'") # DEBUG
        full_mus_track_data = parsed_data['tracks'][mus_track_key]
        mml_channel_id = MUS_TO_NDP_TRACK_MAP.get(mus_track_key.upper())
        verbose_flag = parsed_data.get('verbose', False) # parse_mus_fileからverboseフラグを取得

        if not mml_channel_id:
            # print(f"Warning: Skipping MUS track '{mus_track_key}' as it has no MML channel mapping.")
            continue

        processed_tracks_output.append(f"// トラック {mus_track_key.upper()} (チャンネル {mml_channel_id})")
        
        # Call process_mus_commands with the full track data and the MML channel ID
        # process_mus_commands は単一のMML文字列を返すように変更された
        single_mml_track_string = process_mus_commands(
            full_mus_track_data, 
            mml_channel_id, 
            verbose=verbose_flag, 
            is_pdx_mode=False, # is_pdx_mode は必要に応じて調整
            current_timebase=timebase
        )
        
        # --- DEBUG: Before splitting --- 
        if verbose_flag:
            print(f"\nDEBUG convert_mml_file: For MUS track '{mus_track_key}' (MML Channel '{mml_channel_id}')")
            print(f"DEBUG convert_mml_file: Data from process_mus_commands (first 100): '{str(single_mml_track_string)[:100]}'")
        # --- END DEBUG ---
        
        # 単一のMML文字列を、新しいsplit_track_dataを使って行に分割
        mml_track_lines_split = split_track_data(
            single_mml_track_string, 
            mml_channel_id, 
            max_length=MAX_LINE_LENGTH_MMLE, 
            verbose=verbose_flag
        )
        
        processed_tracks_output.extend(mml_track_lines_split)
        processed_tracks_output.append('') # Add a blank line after each track's MML content

    mml_output_parts.extend(processed_tracks_output)
    
    final_mml_content = "\n".join(mml_output_parts).strip()
    # Ensure the file ends with a newline, even if it's empty
    return final_mml_content + "\n" if final_mml_content else "\n"

def convert_mml_file(mus_filepath, conversion_mode="default", note_length_mode="frames"):
    """
    MUSファイルをNDP形式に変換します。
    
    Args:
        mus_filepath: 入力MUSファイルのパス
        conversion_mode: 変換モード ('default' または 'direct_8track')
        note_length_mode: ノート長の変換モード ('frames' または 'ticks')
    Returns:
        str: 変換されたNDP形式の文字列
    """
    # 変換モードの検証
    if conversion_mode not in ["default", "direct_8track"]:
        return f"エラー: 無効な変換モード: {conversion_mode}"
    
    # ノート長モードの検証
    if note_length_mode not in ["frames", "ticks"]:
        return f"エラー: 無効なノート長モード: {note_length_mode}"
    try:
        with open(mus_filepath, 'r', encoding='utf-8', errors='replace') as f:
            mus_content = f.read()
    except Exception as e:
        return f"Error reading MUS file: {e}"

    # MUSファイルからタイトルと作曲者を抽出
    mus_title = re.search(r"#TITLE\s*(.*)", mus_content, re.IGNORECASE)
    mus_composer = re.search(r"#COMPOSER\s*(.*)", mus_content, re.IGNORECASE)
    mus_title_str = mus_title.group(1).strip() if mus_title else "Untitled"
    mus_composer_str = mus_composer.group(1).strip() if mus_composer else "Unknown Composer"

    # NDPフォーマットのヘッダーを設定
    converted_mml_content = f'#TITLE "{mus_title_str}"\n#COMPOSER "{mus_composer_str}"\n#TIMEBASE {NDP_TIMEBASE}\n\n'

    # MUSファイルの前処理（コメントや不要な定義を削除）
    mus_content_no_meta = preprocess_mus_remove_definitions_and_comments(mus_content)
    
    tracks_data_mus = {}
    current_track_id_mus = None
    for line in mus_content_no_meta.splitlines():
        line_stripped = line.strip()
        if not line_stripped:
            continue

        # トラックIDのパターン (#A-Hで始まり、その後ろにMMLデータが続く形式)
        # グループ1: トラックID (例: "A", "B")
        # グループ2: トラックIDの後のMMLデータ
        track_match = re.match(r'^#([A-H])\s*(.*)', line_stripped, re.IGNORECASE)

        if track_match:
            # MUS形式では #A, #B のような形式なので、グループ1がトラックID
            current_track_id_mus = track_match.group(1).upper()
            
            if current_track_id_mus not in tracks_data_mus:
                tracks_data_mus[current_track_id_mus] = []
            
            # トラックID行自体に含まれるMMLデータを取得
            mml_data_on_track_line = track_match.group(2).strip()
            if mml_data_on_track_line:
                tracks_data_mus[current_track_id_mus].append(mml_data_on_track_line)
        elif current_track_id_mus is not None:
            # 前の行がトラックID行で、現在の行がその続きのMMLデータの場合
            tracks_data_mus[current_track_id_mus].append(line_stripped)
    
    # MUSトラックIDからNDPトラックIDへのマッピング
    mus_to_ndp_track_map = {
        'A': '1', 'B': '2', 'C': '3', 'D': '4', 'E': '5', 'F': '6', 'G': '7', 'H': '8'
    }
    
    # トラックデータの処理と変換
    processed_tracks = []
    for mus_track_id, mus_track_lines in tracks_data_mus.items():
        # MUSトラックをトークン化
        mus_track_tokens = tokenize_mus_track_data(mus_track_lines)
        
        # トラックIDのマッピング（MUSトラックID → NDPトラックID）
        target_ndp_track_id = mus_to_ndp_track_map.get(mus_track_id, mus_track_id)
        
        # 変換モードに応じたトラックIDの処理
        if conversion_mode == "direct_8track" and mus_track_id in mus_to_ndp_track_map:
            # 8トラック直接マッピングモード
            target_ndp_track_id = mus_to_ndp_track_map[mus_track_id]
        elif mus_track_id not in mus_to_ndp_track_map:
            # 定義されていないトラックIDはスキップ
            continue

        # トラックデータをNDP形式に変換
        track_data_converted = convert_track_data(
            mus_track_tokens, 
            initial_octave=4, 
            initial_default_len=8, 
            initial_bpm=120,
            mus_channel_id=mus_track_id, 
            target_ndp_track_id=target_ndp_track_id,
            conversion_mode=conversion_mode, 
            note_length_conversion_mode=note_length_mode
        )
        
        if track_data_converted.strip():  # 空のトラックは追加しない
            processed_tracks.append((target_ndp_track_id, track_data_converted))
    
    # NDPトラックIDでソートしてから結合 (辞書順ではなく数値順ソートを意識)
    processed_tracks.sort(key=lambda x: int(x[0]) if x[0].isdigit() else float("inf")) 
    for ndp_id, track_content_raw in processed_tracks:
        if track_content_raw.strip(): # 空のトラックは追加しない
            # 各行の先頭にトラックIDを付与する
            track_lines_with_id = []
            for line in track_content_raw.splitlines():
                if line.strip(): # 空行は無視
                    track_lines_with_id.append(f"{ndp_id} {line.strip()}")
            if track_lines_with_id: # トラックに内容がある場合のみ追加
                converted_mml_content += "\n" + "\n".join(track_lines_with_id) + "\n"
    
    # 変換結果を返す
    return converted_mml_content.strip() # 末尾の余分な改行を削除

def convert_mml_file(mus_filepath, conversion_mode="default", note_length_mode="frames"):
    """
    MUSファイルをMML形式に変換します。
    (Refactored to use parse_mus_file for track extraction)
    
    Args:
        mus_filepath: 入力MUSファイルのパス
        conversion_mode: (現在は主にMML生成のため影響小)
        note_length_mode: (現在は主にMML生成のため影響小)
    Returns:
        str: 変換されたMML形式の文字列
    """
    # conversion_mode validation (kept for signature compatibility)
    if conversion_mode not in ["default", "direct_8track"]:
        # For MML conversion, this might not be strictly necessary, but keep for now
        print(f"Warning: conversion_mode '{conversion_mode}' might not be fully applicable for MML output.")
    
    try:
        with open(mus_filepath, 'r', encoding='utf-8', errors='replace') as f:
            mus_content = f.read()
    except Exception as e:
        return f"Error reading MUS file: {e}"

    # Parse the MUS file content using the dedicated parser
    parsed_data = parse_mus_file(mus_content) # parse_mus_file should be defined before this

    title = parsed_data.get('title', "Untitled")
    composer = parsed_data.get('composer', "Unknown")
    
    timebase = 48 # Default MML timebase
    if 'NDP_TIMEBASE' in globals(): # Check if global constant exists and prefer it
        timebase = NDP_TIMEBASE

    mml_output_parts = [
        f'#TITLE "{title}"',
        f'#COMPOSER "{composer}"',
        f'#TIMEBASE {timebase}',
        '' # Blank line after header
    ]

    # Instrument definitions (add as comments)
    if parsed_data.get('instruments'):
        mml_output_parts.append("// インストゥルメント定義")
        for inst_id, inst_data_str in sorted(parsed_data['instruments'].items()):
            # Clean up instrument data string for comment display
            inst_comment = str(inst_data_str).replace('\n', ' ').replace('\r', ' ').replace('\t', ' ')
            inst_comment = re.sub(r'\s+', ' ', inst_comment).strip() # Replace multiple spaces
            mml_output_parts.append(f"// {inst_id} = {inst_comment}")
        mml_output_parts.append('') # Blank line

    # --- DEBUG: Contents of parsed_data['tracks'] before loop ---
    print("\nDEBUG convert_mml_file: --- Contents of parsed_data['tracks'] before loop ---")
    if 'tracks' in parsed_data and isinstance(parsed_data['tracks'], dict):
        for key, value in parsed_data['tracks'].items():
            print(f"DEBUG convert_mml_file: Track '{key}': '{str(value)[:100]}'")
    else:
        print("DEBUG convert_mml_file: 'tracks' key not found or not a dict in parsed_data")
    print("DEBUG convert_mml_file: --- End Contents of parsed_data['tracks'] ---\n")
    # --- END DEBUG ---

    # Track data processing
    # Use MUS_TO_NDP_TRACK_MAP for mapping MUS track chars (A,B,C) to MML channel numbers (1,2,3)
    # This map is globally defined in the file.
    
    processed_tracks_output = []
    # Sort by MUS track character for consistent MML output order
    sorted_mus_track_keys = sorted(parsed_data.get('tracks', {}).keys())
    print(f"DEBUG convert_mml_file: Sorted MUS track keys for loop: {sorted_mus_track_keys}") # DEBUG

    for mus_track_key in sorted_mus_track_keys:
        print(f"DEBUG convert_mml_file: LOOP START: Current mus_track_key = '{mus_track_key}'") # DEBUG
        full_mus_track_data = parsed_data['tracks'][mus_track_key]
        mml_channel_id = MUS_TO_NDP_TRACK_MAP.get(mus_track_key.upper())
        verbose_flag = parsed_data.get('verbose', False) # parse_mus_fileからverboseフラグを取得

        if not mml_channel_id:
            # print(f"Warning: Skipping MUS track '{mus_track_key}' as it has no MML channel mapping.")
            continue

        processed_tracks_output.append(f"// トラック {mus_track_key.upper()} (チャンネル {mml_channel_id})")
        
        # Call process_mus_commands with the full track data and the MML channel ID
        # process_mus_commands は単一のMML文字列を返すように変更された
        single_mml_track_string = process_mus_commands(
            full_mus_track_data, 
            mml_channel_id, 
            verbose=verbose_flag, 
            is_pdx_mode=False, # is_pdx_mode は必要に応じて調整
            current_timebase=timebase
        )
        
        # --- DEBUG: Before splitting --- 
        if verbose_flag:
            print(f"\nDEBUG convert_mml_file: For MUS track '{mus_track_key}' (MML Channel '{mml_channel_id}')")
            print(f"DEBUG convert_mml_file: Data from process_mus_commands (first 100): '{str(single_mml_track_string)[:100]}'")
        # --- END DEBUG ---
        
        # 単一のMML文字列を、新しいsplit_track_dataを使って行に分割
        mml_track_lines_split = split_track_data(
            single_mml_track_string, 
            mml_channel_id, 
            max_length=MAX_LINE_LENGTH_MMLE, 
            verbose=verbose_flag
        )
        
        processed_tracks_output.extend(mml_track_lines_split)
        processed_tracks_output.append('') # Add a blank line after each track's MML content

    mml_output_parts.extend(processed_tracks_output)
    
    final_mml_content = "\n".join(mml_output_parts).strip()
    # Ensure the file ends with a newline, even if it's empty
    return final_mml_content + "\n" if final_mml_content else "\n"

# --- MUS to NDP Mappings ---
MUS_TO_NDP_OCTAVE_OFFSET = 0  # オクターブのオフセット（必要に応じて調整）

# トラックIDのマッピング (MUSトラックID → NDPトラックID)
MUS_TO_NDP_TRACK_MAP = {
    'A': '1', 'B': '2', 'C': '3', 'D': '4', 
    'E': '5', 'F': '6', 'G': '7', 'H': '8'
}

def parse_arguments():
    """
    コマンドライン引数を解析します。
    
    Returns:
        argparse.Namespace: パースされたコマンドライン引数
    """
    parser = argparse.ArgumentParser(description='MUS to MML Converter')
    parser.add_argument('input_file', help='入力MUSファイルのパス')
    parser.add_argument('-o', '--output', help='出力ファイルパス (デフォルト: <input_file>.mml)')
    parser.add_argument('-m', '--mode', choices=['default', 'direct_8track'], default='default',
                      help='変換モード (デフォルト: default)')
    parser.add_argument('-l', '--length-mode', choices=['frames', 'ticks'], default='frames',
                      help='ノート長の変換モード (デフォルト: frames)')
    parser.add_argument('--octave-offset', type=int, default=0,
                      help='オクターブオフセット (デフォルト: 0)')
    parser.add_argument('-v', '--verbose', action='store_true',
                      help='詳細な出力を表示')
    return parser.parse_args()

def main():
    args = parse_arguments()
    
    # 入力ファイルの存在確認
    if not os.path.exists(args.input_file):
        print(f"エラー: 入力ファイルが見つかりません: {args.input_file}", file=sys.stderr)
        sys.exit(1)
    
    # 出力ファイルパスの決定
    if args.output:
        output_path = args.output
    else:
        # 入力ファイル名の拡張子を.mmlに変更
        file_name, _ = os.path.splitext(args.input_file)
        output_path = f"{file_name}.mml"
    
    if args.verbose:
        print(f"変換中: {args.input_file} -> {output_path}")
        print(f"モード: {args.mode}, ノート長モード: {args.length_mode}")
    
    # グローバルなオフセットを設定
    global MUS_TO_NDP_OCTAVE_OFFSET
    MUS_TO_NDP_OCTAVE_OFFSET = args.octave_offset
    
    # 出力ディレクトリが存在するか確認し、必要に応じて作成
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir, exist_ok=True)
        except OSError as e:
            print(f"エラー: 出力ディレクトリの作成に失敗しました: {e}", file=sys.stderr)
            sys.exit(1)
    
    try:
        # ファイルを変換（verboseフラグも渡す）
        result = convert_mml_file(
            args.input_file,
            conversion_mode=args.mode,
            note_length_mode=args.length_mode,
            verbose=args.verbose
        )
        
        # 結果をファイルに保存
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(result)
        
        if args.verbose:
            print(f"変換が完了しました: {output_path}")
            
    except Exception as e:
        print(f"エラー: 変換中にエラーが発生しました: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
